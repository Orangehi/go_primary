//channel 是指通道类型，直接指代某种类型的值的通道。
package main

import (
	"fmt"
)

//通道即是某一个通道类型的值，是该类型的实例，与切片和map类型一样，通道类型也是一直应用类型
//channel只能出现在Goroutine中，否则会出现异常
//支持别名
//type Inchan chan int
//也可以直接申明
//var Inchan chan int

//  x <- y  表示x接收y发送的值,y发送值给x
//  y <- x  表示y接收x发送的值,x发送值给y
// 位于 <- 符号<-左边的是接收者，位于符号<-右边的事发送者

//与其他类型不一样，通道类型的变量是用来传递值的，而不是用来存储值的。
//所以通道类型并没有对应的值表示法。他的值就要即时性，是无法用字面量来表达的

//在同一时刻仅有一个Goroutine能从该channel这里发送值，并且也只能有一个Goroutine能从该channel这里接收值
//通道类型中值的存储方式是队列存储，先进进出，最先取出来的是第一个进入通道的值
//通道中的元素都具有原子性，也就是通道中的所有元素只能被同一个Goroutine接收，已被接收的元素值，会立即被通道删除。

//channel只能通过make(chan int,10)或者make(chan int)来初始化。
//第一种初始化方式是建立一个可以缓冲10个数据的通道。也称为缓冲通道。
//第二种初始化方式是建立一个不能缓冲数据的通道
//也就是说，向该通道发送一个数据，必须同时向该通道接收一个数据，否则会造成堵塞。

//缓冲通道
//接收元素值
//当向刚初始化的通道接收数据时，因为该通道中并没有缓冲数据，所以，会造成阻塞。
//当接收一个缓冲通道的时候，无论是在该通道接收动作之前还是接收动作期间关闭该通道，都将会返回该通道的零值。
//所以， x,ok := <- chan int,OK将被赋予一个bool值，true代表接收成功，false代表接收失败
//我们向一个已经被关闭的通道接收数据，不会引起异常。
//如果我们向值为nil的通道接收一个值，那么当前Goroutine会被永久阻塞。使用前一定要初始化通道。

//发送元素值
//如果我们向一个已经满了的通道发送元素，会造成一个堵塞。知道该通道中的元素被接收，腾出存储空间为止
//如果我们向值为nil的通道发送一个值，那么当前Goroutine会被永久阻塞。使用前一定要初始化通道。
//如果我们试图向一个已经被关闭的通道发送值的话，会出现运行时恐慌。
//即时是向该通道发送数据，因为该通道已满而被阻塞，关闭该通道，也会造成一个运行时恐慌。
//我们不希望因为通道的关闭而导致程序被迫中断
//为了避免这种恐慌，我们会在select代码块中执行
//当出现多个Goroutine向同一个通道发送数据的时候，该通道已满，这些Goroutine被阻塞。
//当该通道被接收了数据，腾出了位置，那么第一个向通道发送数据而被阻塞的Goroutine会首先被唤醒，完成发送操作（顺序执行）
//当多个Goroutine向同一个通道接收数据，该通道没有数据的时候，这些Goroutine被阻塞。
//当该通道被发送了数据，通道内有了数据，那么第一个向通道接收数据而被阻塞的Goroutine会首先被唤醒，完成接收操作(顺序执行)
//无论是接收操作还是发送操作，运行时系统每次之后唤醒一个Goroutine。
//我们向一个通道发送x,发送的只是x的一个副本，并非x值本身。对x的一系列操作，都不会印象通道内的x的副本

//单向通道
//单向通道分为只能接收通道或者只能发送通道
//无论是哪一种通道的申明初始化都不能在变量中直接申明

//缓冲通道与for
//for v := range chan type{
//}
//如果该通道没有被关闭，for语句会不断地尝试从通道中接收数据，出现死锁
//当通道被关闭，for语句会接收当前通道的所有值。
//所以使用for语句接收通道的值，最好首先关闭该通道

//缓冲通道与select
//select{
//case :
//case :
//default:
//}
//每个case语句后面只能跟一个接收通道操作或者发送通道操作，可以跟default语句
//每个case后面的接受操作或者发送操作语句或者元素表达式都将被求值，不管该case有没有满足条件。
//求值的顺序是从上到下，从左到右
//case后面的通道操作语句中的通道可以为nil，但是该case语句会被select永久忽略，这将没有任何意义
//在执行select语句的时候，运行时环境会自上而下地判断每一个case中的接受或者发送操作是否会被立即执行。
//这个立即执行的意思是该Goroutine不会因为该通道操作而堵塞。
//当只有一个case满足时，其他case会被忽略。
//当多个case同时满足时，将使用伪随机的算法来确定拿一个case将被执行
//如果所有case都不满足，并且该select没有default时，该Goroutine将被阻塞于此，知道某个case可以立即执行为止。
//如果所有case的通道都为nil那么该Goroutine将被永久阻塞

func main() {

	c := make(chan int, 5)
	b := make(chan int, 2)
	go func() {

		for i := 0; i < 5; i++ {

			c <- i

		}
		close(c)
		b <- 1

	}()
	go func() {

		for v := range c {

			fmt.Println(v)
		}

		b <- 2

	}()

	<-b
	<-b

}
